#summary PLUTO - PL/SQL Unit Testing for Oracle
#labels Featured,Pluto,testing,oracle,testdrivendevelopment,plsql

= Introduction =

Unit testing your PL/SQL from inside Oracle doesn't have to be difficult or expensive.  There is no need to be tied into some third-party closed source tool and no reason to start from scratch writing your own framework.  PLUTO can help get you started on the road to unit testing bliss, or at least unit testing.

= Installing PLUTO =

Installation couldn't be much easier, just [http://code.google.com/p/pluto-test-framework/downloads/list download the latest version] of the PLUTO source to a machine that can connect to your database, unpack the source file, and run:

{{{
  $> sqlplus @install.sql
}}}

It is recommended that you run the command in a schema called PLUTO and that the PLUTO schema have 'create type' privileges.

If you have any issues with the install, please be sure to [http://code.google.com/p/pluto-test-framework/issues/list log them].  Be sure to mention the version of Oracle that you are running.  And better yet, if you figured out how to fix the issue, please send in the patch.

== What is installed? ==

PLUTO is intended to be a lightweight system for unit testing.  It doesn't create any tables or store a lot of data.  Instead, it creates a TYPE and a handful of objects.

|| pluto_proc_name_tab || A type equivalent to a varchar2(30) ||
|| pluto_output_obj || An object used for the default output from the testing framework.  This object can be extended to accommodate just about any desired output format. ||
|| pluto_output_tap_obj || An example of extending the default pluto_output_obj.  This custom output object writes results in TAP, the Test Anything Protocol used by the [http://www.perl.org Perl] testing system, Test::Harness. ||
|| pluto_util_obj || Utility methods for test assertions. ||
|| pluto_obj || The core package for the testing framework.  This object is the object that custom test classes extend in order to get the benefit of the PLUTO interpretation of xUnit ||



= Getting Started Unit Testing With PLUTO =

After installing PLUTO, you are ready to start writing unit tests.  You might be interested in some [http://pluto-test-framework.googlecode.com/svn/trunk/examples/ test examples].  The text below highlights what you'll see in some of that example code.

To get started using PLUTO, you just have to subclass the main PLUTO object, pluto_obj.  To do this in Oracle, you'll need to create a package specification.

{{{
  create or replace type testing_obj under pluto_obj(
  )
  instantiable not final;
}}}

Of course, this specification doesn't really accomplish much other than to create a child class of _pluto_obj_.  We won't realize how powerful that is until a little later in this tutorial.

Adding some meat to the object, let's include a specification for a constructor.

{{{
  create or replace type testing_obj under pluto_obj(
    constructor function testing_obj
      return self as result
  )
  instantiable not final;
}}}

The implementation of the constructor simply creates a utility object and an output object.  The utility object is stashed away in _m_util_object_.  _m_util_object_ is an attribute of _pluto_obj_ that is intended to store the utility object.  Typically, this part of the test class construction will be very similar to what you see below, with the exception being the type of output object constructed and passed to the utility object constructor.

The type of output object chosen at this point of your testing is very important.  It determines what type of data will be emitted from the testing suite at runtime, be it the default human-readable data, TAP, inserts into a logging table, or some combination of all of the above.  In the case below, we settle on using the default human-readable form of output object.

{{{
  create or replace type body testing_obj is
    constructor function testing_obj
      return self as result is
    begin
      m_util_object              :=
                     pluto_util_obj( output_object => pluto_output_obj( ));
      return;
    end testing_obj;
  end;
}}}

Excellent, we now have the minimum amount of code necessary to run unit tests through PLUTO, but we have a problem... have you spotted it?

We don't have any tests!

Let's add a test to our new testing object.

{{{
  create or replace type testing_obj under pluto_obj(
    member procedure test_one,
    constructor function testing_obj
      return self as result
  )
  instantiable not final;
}}}

{{{
  create or replace type body testing_obj is
    member procedure test_one is
    begin
      m_util_object.ok(
        test_passed    => true,
        test_label     => 'running test_one'      ||
                          chr( 10 )               ||
                          'i hope that it worked'
      );
    end test_one;
    constructor function testing_obj
      return self as result is
    begin
      m_util_object              :=
                     pluto_util_obj( output_object => pluto_output_obj( ));
      return;
    end testing_obj;
  end;
}}}

Okay, so it's not the most exciting test, but it works.  You can see in the first part of the listing that we add a procedure specification called _test_one_.  Later, we define that procedure in the type body.  In the definition we invoke the _ok_ method from the utility object, passing it a boolean value for the status of the test and a test label.

In order to run the test, we simply run an anonymous PL/SQL block.

{{{
  declare
    ut_obj  my_test_obj := my_test_obj( );
  begin
    ut_obj.run_tests;
  end;
}}}

This executes the _test_one_ test and prints the results to the standard Oracle output stream.  Of course, there is a lot more to PLUTO than simply running test methods one after another.  PLUTO implements xUnit-style testing, which we'll go over shortly.  Also, there is a host of functions and procedures available in the PLUTO utility module.